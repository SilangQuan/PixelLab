#version 430
layout (local_size_x =16, local_size_y = 16) in;
layout(binding=0, rgba8) uniform mediump image2D inputImage;
layout(binding=1, rgba8) uniform mediump image2D resultImage;

// 16x acceleration of https://www.shadertoy.com/view/4tSyzy
// by applying gaussian at intermediate MIPmap level.

const int samples = 35,
          LOD = 2, // gaussian done on MIPmap at scale LOD
          sLOD = 1 << LOD; // tile size = 2^LOD
const float sigma = float(samples) * .25;

float gaussian(vec2 i)
{
	return exp(-.5 * dot(i /= sigma, i)) / (6.28 * sigma * sigma);
}


void main()
{
	float u = float(gl_GlobalInvocationID.x);
	float v = float(gl_GlobalInvocationID.y);
	ivec2 id = ivec2(gl_GlobalInvocationID.xy);
	
	ivec2 size = imageSize(resultImage);
	if (u >= size.x || v >= size.y)
	{
		return;
	}
	float uSigma = 5.2;
	
	 // 0.9544
	int kernel = int(ceil(2.0 * uSigma));

	vec4 pixel = vec4(0.0);
	float coef = 0.0;
	for (int dx = -kernel; dx <= kernel; dx++)
	{
		for (int dy = -kernel; dy <= kernel; dy++)
		{
			int x = id.x + dx;
			int y = id.y + dy;
			if (x < 0 || x >= size.x || y < 0 || y >= size.y)
			{
				continue;
			}
			float c = exp(-float(dx * dx + dy * dy) / (2.0 * uSigma * uSigma + 1e-5));
			pixel += (imageLoad(inputImage, ivec2(x, y)) * c);
			coef += c;
		}
	}
	imageStore(resultImage, ivec2(u, v), pixel / (coef + 1e-5));
	
	/*
	vec4 result = vec4(0);
	int s = samples / sLOD;
	float scale = 1.0f;
    
	for (int i = 0; i < s * s; i++)
	{
		vec2 d = vec2(i % s, i / s) * float(sLOD) - float(samples) / 2.;
		//result += gaussian(d) * imageLoad(inputImage, ivec2(u, v) + ivec2(scale * d));
		result += gaussian(d) * imageLoad(inputImage, ivec2(u, v));
	}
    
	result += 0.25 * imageLoad(inputImage, ivec2(u, v));
	result += 0.25 * imageLoad(inputImage, ivec2(u, v) + ivec2(-1, -1));
	result += 0.25 * imageLoad(inputImage, ivec2(u, v) + ivec2(-1, 1));
	result += 0.25 * imageLoad(inputImage, ivec2(u, v) + ivec2(1, 1));
	
	

	//vec4 result = blur(inputImage, ivec2(u, v), ivec2(0.1, 0.1));
	
	imageStore(resultImage, ivec2(u, v), result);
*/
}

