#version 430 core
#define TILE_SIZE 16
#define MAX_LIGHTS_PER_TILE 4

struct Light {
	vec3 position;
	float radius;
	vec3 color;
	float intensity;
};

layout(std430, binding = 0) readonly buffer lights_data {
	Light lights[];
};

layout(std430, binding = 1) writeonly buffer visible_lights_indices {
	int lights_indices[];
};

struct View
{
	mat4 View;
	mat4 Projection;
	mat4 ViewProjection;
	mat4 InvProjection;
	vec4 ScreenSizeAndInv;
	vec4 ZParams;
};

uniform int num_lights;
uniform View ViewInfo;

uniform sampler2D depthmap;

shared uint min_depth;
shared uint max_depth;
shared vec4 frustum_planes[6];
shared uint group_light_count;
shared int group_light_index[MAX_LIGHTS_PER_TILE];

// convert a depth value from post-projection space into view space
float ConvertProjDepthToView(float z)
{
	float Zv = 1.f / (ViewInfo.ZParams.y - z * ViewInfo.ZParams.x);
	return Zv;
}

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE) in;
void main() {

	ivec2 tileID = ivec2(gl_WorkGroupID.xy);
	ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);

	ivec2 tile_id = ivec2(gl_WorkGroupID.xy);

	if (gl_LocalInvocationIndex == 0) {
		min_depth = 0xFFFFFFFF;
		max_depth = 0x0;
		group_light_count = 0;
		uint index = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
		uint offset = index * MAX_LIGHTS_PER_TILE;
		for (uint i = 0; i < MAX_LIGHTS_PER_TILE; i++) {
			lights_indices[offset + i] = -1;
		}
	}
	barrier();

	// Compute depth min and max of the workgroup
	vec2 screen_uv = gl_GlobalInvocationID.xy / ViewInfo.ScreenSizeAndInv.xy;

	float depth = texture(depthmap, screen_uv).r;

	float viewPosZ = ConvertProjDepthToView(depth);

	//depth = (0.5 * ViewInfo.Projection[3][2]) / (depth + 0.5 * ViewInfo.Projection[2][2] - 0.5);
	uint depth_uint = floatBitsToUint(depth);
	atomicMin(min_depth, depth_uint);
	atomicMax(max_depth, depth_uint);

	barrier();

	// Compute Tile frustrum planes
	if (gl_LocalInvocationIndex == 0) {
		// Convert the min and max across the entire tile back to float
		float minDepth = uintBitsToFloat(min_depth);
		float maxDepth = uintBitsToFloat(max_depth);

		// Steps based on tile sale
		vec2 negativeStep = (2.0 * vec2(tileID)) / vec2(tileNumber);
		vec2 positiveStep = (2.0 * vec2(tileID + ivec2(1, 1))) / vec2(tileNumber);

		// Set up starting values for planes using steps and min and max z values
		frustum_planes[0] = vec4(1.0, 0.0, 0.0, 1.0 - negativeStep.x); // Left
		frustum_planes[1] = vec4(-1.0, 0.0, 0.0, -1.0 + positiveStep.x); // Right
		frustum_planes[2] = vec4(0.0, 1.0, 0.0, 1.0 - negativeStep.y); // Bottom
		frustum_planes[3] = vec4(0.0, -1.0, 0.0, -1.0 + positiveStep.y); // Top
		frustum_planes[4] = vec4(0.0, 0.0, -1.0, -minDepth); // Near
		frustum_planes[5] = vec4(0.0, 0.0, 1.0, maxDepth); // Far

		// Transform the first four planes
		for (uint i = 0; i < 4; i++) {
			frustum_planes[i] *= ViewInfo.ViewProjection;
			frustum_planes[i] /= length(frustum_planes[i].xyz);
		}

		// Transform the depth planes
		frustum_planes[4] *= ViewInfo.View;
		frustum_planes[4] /= length(frustum_planes[4].xyz);
		frustum_planes[5] *= ViewInfo.View;  
		frustum_planes[5] /= length(frustum_planes[5].xyz);
	}

	barrier();

	// Cull lights
	uint thread_count = TILE_SIZE * TILE_SIZE;
	for (uint i = gl_LocalInvocationIndex; i < num_lights; i += thread_count) {
		Light light = lights[i];
		vec4 vs_light_pos = ViewInfo.View * vec4(light.position, 1.0);

		if (group_light_count < MAX_LIGHTS_PER_TILE) {
			bool inFrustum = true;
			for (uint j = 0; j < 4 && inFrustum; j++) {
				float d = dot(frustum_planes[j], vs_light_pos);
				inFrustum = (d >= -light.radius);
			}
			if (inFrustum) {
				uint id = atomicAdd(group_light_count, 1);
				group_light_index[id] = int(i);
			}
		}
	}

	barrier();
	if (gl_LocalInvocationIndex == 0) {
		uint index = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
		uint offset = index * MAX_LIGHTS_PER_TILE;

		for (uint i = 0; i < MAX_LIGHTS_PER_TILE; i++)
		{
			//For debuging.
			//lights_indices[offset + i] = int(offset);
		}

		for (uint i = 0; i < group_light_count; i++) {
			lights_indices[offset + i] = group_light_index[i];
			//For debuging.
			//lights_indices[offset + i] = num_lights ;
		}
	}
}
