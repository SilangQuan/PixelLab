#version 430 core
#define TILE_SIZE 16
#define MAX_LIGHTS_PER_TILE 4
#define FLT_MAX 3.402823466e+38F

struct Light {
	vec3 position;
	float radius;
	vec3 color;
	float intensity;
};

layout (std430, binding = 0) readonly buffer lights_data { 
	Light lights[];
};

layout(std430, binding = 1) writeonly buffer visible_lights_indices {
	int lights_indices[];
};

struct View
{
	mat4 View;
	mat4 Projection;
	mat4 InvProjection;
	vec4 ScreenSizeAndInv;
	vec4 ZParams;
};

uniform int num_lights;
uniform View ViewInfo;

uniform sampler2D depthmap;

shared uint min_depth;
shared uint max_depth;
shared vec4 frustum_planes[6];
shared uint group_light_count;
shared int group_light_index[MAX_LIGHTS_PER_TILE];

// convert a depth value from post-projection space into view space
float ConvertProjDepthToView(float z)
{
	float Zv = 1.f / (ViewInfo.ZParams.y - z * ViewInfo.ZParams.x);
	return Zv;
}

// point-plane distance, simplified for the case where 
// the plane passes through the origin
float GetSignedDistanceFromPlane(in vec4 p, in vec4 eqn)
{
    // dot( eqn.xyz, p.xyz ) + eqn.w, , except we know eqn.w is zero 
    // (see CreatePlaneEquation above)
	return dot(eqn.xyz, p.xyz);
}

// this creates the standard Hessian-normal-form plane equation from three points, 
// except it is simplified for the case where the first point is the origin
vec4 CreatePlaneEquation(vec4 b, vec4 c)
{
	vec4 n;

    // normalize(cross( b.xyz-a.xyz, c.xyz-a.xyz )), except we know "a" is the origin
	n.xyz = normalize(cross(b.xyz, c.xyz));

    // -(n dot a), except we know "a" is the origin
	n.w = 0;

	return n;
}

vec3 CreatePlaneEqu(vec3 b, vec3 c)
{
	vec3 n;

    // normalize(cross( b.xyz-a.xyz, c.xyz-a.xyz )), except we know "a" is the origin
	n.xyz = normalize(cross(b.xyz, c.xyz));

	return n;
}

float GetSignedDistanceFromPlane(in vec4 p, in vec3 eqn)
{
    // dot( eqn.xyz, p.xyz ) + eqn.w, , except we know eqn.w is zero 
    // (see CreatePlaneEquation above)
	return dot(eqn.xyz, p.xyz);
}

vec4 ConvertProjToView(vec4 p)
{
	p = ViewInfo.InvProjection * p;
	p /= p.w;
    // FIXME: Added the following line, not needed in D3D11 or ForwardPlus11 example. [2014-07-07]
	//p.y = -p.y;
	return p;
}

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE) in;
void main() {
	ivec2 tile_id = ivec2(gl_WorkGroupID.xy);
	uvec3 globalIdx = gl_GlobalInvocationID;
	uvec3 groupIdx = gl_WorkGroupID;
	
	if (gl_LocalInvocationIndex == 0) {
		min_depth = 0xFFFFFFFF;
		max_depth = 0x0;
		group_light_count = 0;
		uint index = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
		uint offset = index * MAX_LIGHTS_PER_TILE;
		for (uint i = 0; i < MAX_LIGHTS_PER_TILE; i++) {
			lights_indices[offset + i] = -1;
		}
	}
	barrier();

	// Compute depth min and max of the workgroup
	vec2 screen_uv = gl_GlobalInvocationID.xy / ViewInfo.ScreenSizeAndInv.xy;

	float depth = texture(depthmap, screen_uv).r;
	
	float viewPosZ = ConvertProjDepthToView(depth);
	float minZ = FLT_MAX;
	float maxZ = 0.0f;
	//depth = (0.5 * ViewInfo.Projection[3][2]) / (depth + 0.5 * ViewInfo.Projection[2][2] - 0.5);
	uint depth_uint = floatBitsToUint(viewPosZ);
	atomicMin(min_depth, depth_uint);
	atomicMax(max_depth, depth_uint);

	barrier();


	vec3 frustumEqn[4];
    {  
		/*
        // construct frustum for this tile
		uint pxm = TILE_SIZE * groupIdx.x;
		uint pym = TILE_SIZE * groupIdx.y;
		uint pxp = TILE_SIZE * (groupIdx.x + 1);
		uint pyp = TILE_SIZE * (groupIdx.y + 1);

		uint uWindowWidthEvenlyDivisibleByTileRes = TILE_SIZE * gl_WorkGroupID.x;
		uint uWindowHeightEvenlyDivisibleByTileRes = TILE_SIZE * gl_WorkGroupID.y;

        // four corners of the tile, clockwise from top-left
		vec4 frustum[4];
		frustum[0] = ConvertProjToView(vec4(pxm / float(uWindowWidthEvenlyDivisibleByTileRes) * 2.0f - 1.0f, (uWindowHeightEvenlyDivisibleByTileRes - pym) / float(uWindowHeightEvenlyDivisibleByTileRes) * 2.0f - 1.0f, 0.0f, 1.0f));
		frustum[1] = ConvertProjToView(vec4(pxp / float(uWindowWidthEvenlyDivisibleByTileRes) * 2.0f - 1.0f, (uWindowHeightEvenlyDivisibleByTileRes - pym) / float(uWindowHeightEvenlyDivisibleByTileRes) * 2.0f - 1.0f, 0.0f, 1.0f));
		frustum[2] = ConvertProjToView(vec4(pxp / float(uWindowWidthEvenlyDivisibleByTileRes) * 2.0f - 1.0f, (uWindowHeightEvenlyDivisibleByTileRes - pyp) / float(uWindowHeightEvenlyDivisibleByTileRes) * 2.0f - 1.0f, 0.0f, 1.0f));
		frustum[3] = ConvertProjToView(vec4(pxm / float(uWindowWidthEvenlyDivisibleByTileRes) * 2.0f - 1.0f, (uWindowHeightEvenlyDivisibleByTileRes - pyp) / float(uWindowHeightEvenlyDivisibleByTileRes) * 2.0f - 1.0f, 0.0f, 1.0f));

        // create plane equations for the four sides of the frustum, 
        // with the positive half-space outside the frustum (and remember, 
        // view space is left handed, so use the left-hand rule to determine 
        // cross product direction)
		for (int i = 0; i < 4; i++)
		{
			frustumEqn[i] = CreatePlaneEquation(frustum[i], frustum[(i + 1) & 3]);
		}
		*/
		uint rast_xt = TILE_SIZE * gl_WorkGroupID.x;
		uint rast_yt = TILE_SIZE * gl_WorkGroupID.y;
		uint rast_xb = TILE_SIZE * (gl_WorkGroupID.x + 1);
		uint rast_yb = TILE_SIZE * (gl_WorkGroupID.y + 1);
    

    // Calculate position of the corners of this group's tile in NDC space
    // Different from the AMD DX 11 sample because Vulkan's NDC space has
    // the Y axis pointing downwards
		vec4 top_left = vec4(
      float(rast_xt) / float(ViewInfo.ScreenSizeAndInv.x) * 2.f - 1.f,
      float(rast_yt) / float(ViewInfo.ScreenSizeAndInv.y) * 2.f - 1.f,
      1.f,
      1.f);
		vec4 bottom_left = vec4(
      top_left.x,
      float(rast_yb) / float(ViewInfo.ScreenSizeAndInv.y) * 2.f - 1.f,
      1.f,
      1.f);
		vec4 bottom_right = vec4(
      float(rast_xb) / float(ViewInfo.ScreenSizeAndInv.x) * 2.f - 1.f,
      bottom_left.y,
      1.f,
      1.f);
		vec4 top_right = vec4(
      bottom_right.x,
      top_left.y,
      1.f,
      1.f);

    // Convert the four corners from NDC to view space
		vec3 top_left_vs = ConvertProjToView(top_left).xyz;
		vec3 bottom_left_vs = ConvertProjToView(bottom_left).xyz;
		vec3 bottom_right_vs = ConvertProjToView(bottom_right).xyz;
		vec3 top_right_vs = ConvertProjToView(top_right).xyz;

    // Create plane equations for the four sides of the frustum,
    // with the positive half space outside the frustum. Also
    // change the handedness from left to right compared to the AMD
    // DX 11 sample, since we chose the view space to be right handed
		frustumEqn[0] = CreatePlaneEqu(top_right_vs, top_left_vs);
		frustumEqn[1] = CreatePlaneEqu(top_left_vs, bottom_left_vs);
		frustumEqn[2] = CreatePlaneEqu(bottom_left_vs, bottom_right_vs);
		frustumEqn[3] = CreatePlaneEqu(bottom_right_vs, top_right_vs);
		
	}

	barrier();

	maxZ = uintBitsToFloat(max_depth);
	minZ = uintBitsToFloat(min_depth);
	// Cull lights
	uint thread_count = TILE_SIZE * TILE_SIZE;
	for (uint i = gl_LocalInvocationIndex; i < num_lights; i += thread_count)
	{
	
		if (group_light_count < MAX_LIGHTS_PER_TILE)
		{
			//Debug depth bound
			//uint dstIdx = atomicAdd(group_light_count, 1);
			//group_light_index[dstIdx] = int(minZ * 1000);
			
			
			Light light = lights[i];
			
			//Be careful about pos in view coordinate.
			vec4 center = ViewInfo.View * vec4(light.position, 1.0);
			float r = light.radius;
			
			if (-center.z < r + maxZ && minZ - r < -center.z)
			{
				if ((GetSignedDistanceFromPlane(center, frustumEqn[0]) < 1) &&
                    (GetSignedDistanceFromPlane(center, frustumEqn[1]) < 1) &&
                    (GetSignedDistanceFromPlane(center, frustumEqn[2]) < 1) &&
                    (GetSignedDistanceFromPlane(center, frustumEqn[3]) < 1))
				{
                    // do a thread-safe increment of the list counter 
                    // and put the index of this light into the list
					uint dstIdx = atomicAdd(group_light_count, 1);
					group_light_index[dstIdx] = int(i);
				}
					
			}
			
		}
	}

	barrier();
	if (gl_LocalInvocationIndex == 0) {
		uint index = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
		uint offset = index * MAX_LIGHTS_PER_TILE;

		for (uint i = 0; i < MAX_LIGHTS_PER_TILE; i++) 
		{
			//For debuging.
			//lights_indices[offset + i] = int(offset);
		}

		for (uint i = 0; i < group_light_count; i++) {
			lights_indices[offset + i] = group_light_index[i];
			//For debuging.
			//lights_indices[offset + i] = num_lights ;
		}
	}
}
